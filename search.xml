<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MacOS 下的 Azure Cli</title>
    <url>/2020/07/16/MacOS-%E4%B8%8B%E7%9A%84-Azure-Cli/</url>
    <content><![CDATA[<h3 id="使用-CLI-控制-Azure-服务"><a href="#使用-CLI-控制-Azure-服务" class="headerlink" title="使用 CLI 控制 Azure 服务"></a>使用 CLI 控制 Azure 服务</h3><a id="more"></a>
<h4 id="什么是-Azure-CLI？"><a href="#什么是-Azure-CLI？" class="headerlink" title="什么是 Azure CLI？"></a>什么是 Azure CLI？</h4><p>Azure CLI 是一个命令行程序，可连接到 Azure 并对 Azure 资源执行管理命令。 它在 Linux、macOS 和 Windows 上运行，并允许管理员和开发人员通过终端或命令行提示符（或脚本！）而不是 Web 浏览器执行命令。 例如，要重启虚拟机 (VM)，可使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az vm restart -g MyResourceGroup -n MyVm</span><br></pre></td></tr></table></figure>

<p>Azure CLI 提供用于管理 Azure 资源的跨平台命令行工具，可以在 Linux、Mac 或 Windows 计算机上本地安装。 此外，可以从浏览器中通过 Azure Cloud Shell 使用 Azure CLI。 通过这两种方式，均可以交互方式或编写脚本的方式使用 Azure CLI。 若要以交互方式使用，请先在 Windows 上启动 cmd.exe 等 shell 或是在 Linux 或 macOS 上启动 Bash，然后在 shell 提示符处发出命令。 若要自动执行重复性任务，请使用所选 shell 的脚本语法将 CLI 命令配置到 shell 脚本中，然后执行该脚本。</p>
<h4 id="如何安装-Azure-CLI"><a href="#如何安装-Azure-CLI" class="headerlink" title="如何安装 Azure CLI"></a>如何安装 Azure CLI</h4><p>在 Linux 和 macOS 上，均使用包管理器安装 Azure CLI。 建议使用的包管理器因 OS 和分发而异：</p>
<p>Linux：Ubuntu 上的 apt-geton、Red Hat 上的 yum 和 OpenSUSE 上的 zypper<br>Mac：Homebrew<br>Microsoft 存储库中提供 Azure CLI，因此需要先将该存储库添加到包管理器中。</p>
<p>在 Windows 上，可通过下载并运行 MSI 文件安装 Azure CLI。</p>
<p>Azure CLI 的当前版本为 2.8.0。 有关最新版本的信息，请参阅发行说明。 若要查找你已安装的版本并查看是否需要更新，请运行 az –version。</p>
<h4 id="使用-Homebrew-安装"><a href="#使用-Homebrew-安装" class="headerlink" title="使用 Homebrew 安装"></a>使用 Homebrew 安装</h4><p>Homebrew 是管理 CLI 安装的最容易的方法。 它可以方便地进行安装、更新和卸载。 如果系统中没有可用的 Homebrew，请先安装 Homebrew，然后继续。<br>安装 CLI 时，可以先更新 brew 存储库信息，然后运行 install 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew update &amp;&amp; brew install azure-cli</span><br></pre></td></tr></table></figure>

<p>然后即可使用 <code>az</code> 命令来运行 Azure CLI。 若要登录，请使用 <code>az login</code> 命令。<br>运行 <code>login</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az login</span><br></pre></td></tr></table></figure>

<p>如果 CLI 可以打开默认浏览器，它将这样做并加载 Azure 登录页。<br>否则，请在 <a href="https://aka.ms/devicelogin" target="_blank" rel="noopener">https://aka.ms/devicelogin</a> 处打开浏览器页，然后输入终端中显示的授权代码。</p>
<h5 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h5><p>CLI 定期使用 Bug 修复、改进、新功能和预览版功能进行更新。 新版本大约两周发布一次。 更新本地存储库信息，然后升级 azure-cli 包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew update &amp;&amp; brew upgrade azure-cli</span><br></pre></td></tr></table></figure>

<h5 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h5><p>使用 Homebrew 卸载 azure-cli 包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew uninstall azure-cli</span><br></pre></td></tr></table></figure>

<h4 id="国区环境下的-Azure-CLI"><a href="#国区环境下的-Azure-CLI" class="headerlink" title="国区环境下的 Azure CLI"></a>国区环境下的 Azure CLI</h4><p>首先使用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az cloud <span class="built_in">set</span> --name AzureChinaCloud</span><br></pre></td></tr></table></figure>

<p>将azure切换到中国区，然后使用 <code>az login</code> 命令进行登录，即可跳转到国区登录界面。</p>
<h4 id="使用-Azure-CLI-可以管理哪些-Azure-资源？"><a href="#使用-Azure-CLI-可以管理哪些-Azure-资源？" class="headerlink" title="使用 Azure CLI 可以管理哪些 Azure 资源？"></a>使用 Azure CLI 可以管理哪些 Azure 资源？</h4><p>通过 Azure CLI，几乎可以控制每个 Azure 资源的各个方面。 可以使用资源组、存储、虚拟机、Azure Active Directory (Azure AD)、容器、机器学习等。</p>
<p>CLI 中的命令由<em>组</em>和_子组_构成。 每个组表示由 Azure 提供的一个服务，而子组将这些服务的命令划分为逻辑分组。 例如，<code>storage</code> 组包含多个子组，包括“account”、“blob”和“queue”。</p>
<p>那么，如何找到所需的特定命令？ 一种方法是使用 az find，AI 机器人将使用 Azure 文档来告诉你有关命令、CLI 等的更多信息。</p>
<p>示例 - 查找与“BLOB”一词相关的最常用命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az find blob</span><br></pre></td></tr></table></figure>

<p>示例 - 向我显示 Azure CLI 命令组的最常用命令，如 az vm。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az find <span class="string">"az vm"</span></span><br></pre></td></tr></table></figure>

<p>示例 - 向我显示 Azure CLI 命令的最常用参数和子命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az find <span class="string">"az vm create"</span></span><br></pre></td></tr></table></figure>

<p>如果已经知道所需命令的名称，该命令的 –help 参数将提供有关该命令的更多详细信息；而对于命令组，将提供可用子命令的列表。 因此，在我们的存储示例中，可按如下方式获取用于管理 blob 存储的子组和命令列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az storage blob --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h4 id="如何创建-Azure-资源"><a href="#如何创建-Azure-资源" class="headerlink" title="如何创建 Azure 资源"></a>如何创建 Azure 资源</h4><p>创建新的 Azure 资源通常分为三个步骤：连接到 Azure 订阅、创建资源以及验证创建是否成功。</p>
<h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><p>由于正在使用 Azure CLI 的本地安装，因此在执行 Azure 命令之前，需要使用 Azure CLI“login”命令进行身份验证。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az login</span><br></pre></td></tr></table></figure>

<p>Azure CLI 通常会启动默认浏览器打开 Azure 登录页面。 如果不起作用，请按照命令行说明操作，并在 <a href="https://aka.ms/devicelogin" target="_blank" rel="noopener">https://aka.ms/devicelogin</a> 中输入授权码。</p>
<p>成功登录后，将连接到 Azure 订阅。</p>
<h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p>由于在创建新的 Azure 服务之前，通常需要创建新的资源组，因此我们将使用资源组作为示例来说明如何从 CLI 创建 Azure 资源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az group create --name &lt;name&gt; --location &lt;location&gt;</span><br></pre></td></tr></table></figure>

<p>例：<code>az group create --name kaciner --location chinanorth</code></p>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>对于许多 Azure 资源，Azure CLI 提供了“list”子命令来查看资源详细信息。 例如，Azure CLI“group list”命令列出了 Azure 资源组。 这对于验证资源组是否成功创建非常有用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az group list</span><br></pre></td></tr></table></figure>

<p>若要获得更简洁的视图，可将输出的格式设为简单的表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az group list --output table</span><br></pre></td></tr></table></figure>

<h4 id="使用资源组"><a href="#使用资源组" class="headerlink" title="使用资源组"></a>使用资源组</h4><h5 id="本例使用-Azure-Cloud-Shell-中的沙盒模式"><a href="#本例使用-Azure-Cloud-Shell-中的沙盒模式" class="headerlink" title="本例使用 Azure Cloud Shell 中的沙盒模式"></a>本例使用 Azure Cloud Shell 中的沙盒模式</h5><p>使用资源组<br>当你使用自己的计算机和 Azure 订阅时，首先需要使用 <code>az login</code> 命令登录到 Azure。 但是，使用基于浏览器的 Cloud Shell 环境时，并非必须进行登录。</p>
<p>接下来，你通常会使用 <code>az group create</code> 命令为所有相关 Azure 资源创建资源组；在本练习中，已为你创建以下资源组：learn-dbf33586-b4a8-4d94-84c5-25b748b07f12。</p>
<ol>
<li>本练习中的第一步是创建几个要在稍后命令中使用的变量。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> RESOURCE_GROUP=learn-dbf33586-b4a8-4d94-84c5-25b748b07f12</span><br><span class="line"><span class="built_in">export</span> AZURE_REGION=centralus</span><br><span class="line"><span class="built_in">export</span> AZURE_APP_PLAN=popupappplan-<span class="variable">$RANDOM</span></span><br><span class="line"><span class="built_in">export</span> AZURE_WEB_APP=popupwebapp-<span class="variable">$RANDOM</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>可以要求 Azure CLI 在表中列出所有资源组。 当你在免费 Azure 沙盒中时，应该只有一个资源组。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az group list --output table</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>随着你完成更多 Azure 开发，可能会生成多个资源组。 如果组列表中有多个项，则可以通过添加 –query 选项来筛选返回值。 请尝试以下命令：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az group list --query <span class="string">"[?name == '<span class="variable">$RESOURCE_GROUP</span>']"</span></span><br></pre></td></tr></table></figure>

<h4 id="创建服务计划的步骤"><a href="#创建服务计划的步骤" class="headerlink" title="创建服务计划的步骤"></a>创建服务计划的步骤</h4><ol>
<li>创建应用服务计划以运行应用。 下述命令指定了免费定价层，但你可运行 az appservice plan create –help 来查看其他定价层。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az appservice plan create --name <span class="variable">$AZURE_APP_PLAN</span> --resource-group <span class="variable">$RESOURCE_GROUP</span> --location <span class="variable">$AZURE_REGION</span> --sku FREE</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">此命令可能需要几分钟才能完成。</span><br><span class="line"></span><br><span class="line">2. 通过在表中列出所有计划来验证是否已成功创建该服务计划。</span><br><span class="line"></span><br><span class="line">``` Bash</span><br><span class="line">az appservice plan list --output table</span><br></pre></td></tr></table></figure>

<h4 id="创建-Web-应用的步骤"><a href="#创建-Web-应用的步骤" class="headerlink" title="创建 Web 应用的步骤"></a>创建 Web 应用的步骤</h4><p>接下来，你将在服务计划中创建 Web 应用。 可同时部署代码，但在本例中，我们将在单独的步骤中分别创建 Web 应用和部署代码。</p>
<ol>
<li>要创建 Web 应用，需提供 Web 应用名称以及在前面创建的应用计划的名称。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az webapp create --name <span class="variable">$AZURE_WEB_APP</span> --resource-group <span class="variable">$RESOURCE_GROUP</span> --plan <span class="variable">$AZURE_APP_PLAN</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过在表中列出所有应用来验证是否已成功创建该应用。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">az webapp list --output table</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>你的站点有一个由 Azure 创建的“快速入门”页，你可以在浏览器中或使用 CURL（只需使用 DefaultHostName 即可）查看它：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl <span class="variable">$AZURE_WEB_APP</span>.azurewebsites.net</span><br></pre></td></tr></table></figure>

<p>你将看到返回的示例应用的默认 HTML。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>内容均来自<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">Microsoft官方文档</a></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>Azure</tag>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>关于计算机网络的基础知识</title>
    <url>/2020/07/15/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="关于计算机网络的基础知识"><a href="#关于计算机网络的基础知识" class="headerlink" title="关于计算机网络的基础知识"></a>关于计算机网络的基础知识</h3><a id="more"></a>
<h4 id="设计网络时要使用的网络类型和拓扑"><a href="#设计网络时要使用的网络类型和拓扑" class="headerlink" title="设计网络时要使用的网络类型和拓扑"></a>设计网络时要使用的网络类型和拓扑</h4><h4 id="什么是网络？"><a href="#什么是网络？" class="headerlink" title="什么是网络？"></a>什么是网络？</h4><p>网络是启用网络的设备的集合，通常由计算机、交换机、路由器、打印机和服务器组成。 网络是日常生活的基本组成部分，它存在于家中、工作场所和公共场所。 网络可以使所有类型的启用网络的设备进行通信。</p>
<h4 id="网络类型"><a href="#网络类型" class="headerlink" title="网络类型"></a>网络类型</h4><p>网络的大小、形状和用法各不相同。 为了更轻松地识别不同的网络类型，其分类为以下网络类别之一：</p>
<ul>
<li>个人区域网<br>个人区域网 (PAN) 围绕个人提供网络需求。</li>
<li>局域网<br>局域网 (LAN) 围绕单个位置提供网络需求</li>
<li>城域网<br>城域网 (MAN) 在城市或大都市区域中的两个不同位置之间提供网络功能，以提供单个广泛网络。 通常，MAN 在每个加入 MAN 的 LAN 之间需要专用的安全连接。</li>
<li>广域网<br>广域网络 (WAN) 在本地或全球的两个不同地理位置之间提供网络功能。</li>
</ul>
<h4 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h4><p>网络拓扑描述网络的物理构成。 我们来了解一下在设计 LAN 时你可以选择的四种拓扑。 它们是：</p>
<ul>
<li>总线<br>在总线拓扑中，每个网络设备都连接到单个网络电缆。 尽管它是可实现的最简单网络类型，但也存在一些限制。 第一个限制是主电缆或总线的长度。 其长度越长，信号丢失的可能性便越大。 此限制会约束网络的物理布局。 所有设备必须在物理上相互靠近，例如在同一房间内。 最后，如果总线电缆中存在中断，则整个网络会发生故障。</li>
<li>环形<br>在环形拓扑中，每个网络设备都连接到其邻居，以形成一个环形。 此形式的网络的复原能力比总线拓扑更强。 环形电缆的中断仍会影响网络的性能。</li>
<li>网格<br>网络拓扑描述为物理网格或逻辑网格。在物理网格中，每个网络设备都连接到网络中的其他所有网络设备。 它会显著提高网络的复原能力，但具有连接所有设备的物理开销。 现在很少有网络构建为完整网格。 大多数网络使用部分网格，其中一些计算机互连，但其他计算机通过一个设备连接。物理网格网络与逻辑网格网络之间存在细微的差异。 人们认为大多数现代网络都基于网格，因为每个设备都可以看到网络上的任何其他设备并与之通信。 此描述属于逻辑网格网络，主要通过使用网络协议来实现。</li>
<li>星形<br>星形拓扑是最常用的网络拓扑。 每个网络设备都连接到集中式集线器或交换机。 交换机和集线器可以链接在一起，以扩展和构建更广泛的网络。 迄今为止，此类型的拓扑的可靠性和可伸缩性最强。</li>
</ul>
<h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><p>以太网是一种网络标准，与基于有线的 LAN 网络同义，也在 MAN 和 WAN 网络中使用。 以太网已取代了其他有线 LAN 技术（如 ARCNET 和令牌环），是行业标准。</p>
<p>虽然以太网与有线网络关联，但请记住，它并不局限于有线，因为它也通过光纤链路使用。</p>
<p>以太网标准为数据传输、错误处理和性能阈值定义了框架。 它描述有关配置以太网，以及网络中每个元素彼此交互的方式的规则。</p>
<p>以太网在 OSI 模型中的数据链接和物理层中使用。 它形成了 IEEE 802.3 标准的基础。 此标准可帮助统一网络和硬件开发。</p>
<p>以太网是持续发展的标准，原始版本仅支持 2.94 Mbps 的数据传输速率。 最近几年，已发布了一些迭代，以满足提速的需求。 如今，速率已扩展到 400 Gbps。</p>
<h4 id="网络基础结构"><a href="#网络基础结构" class="headerlink" title="网络基础结构"></a>网络基础结构</h4><p>多个符合网络标准的设备组成了网络的结构。 根据网络的大小，可能会使用其中几个设备来构建网络的主干。 这些设备有：</p>
<ul>
<li>中继器<br>中继器是一种可重复网络信号的双端口设备。 网络设备之间存在一定距离时，将使用中继器。 中继器在重新发送数据包之前不会修改或解释它们，也不会放大信号。 而是采用原始强度逐位重新生成数据包。</li>
<li>集线器<br>集线器充当网络上的多端口中继器。 使用集线器连接多个设备，并构建网络的布局。 例如，可以级联集线器以创建网络分支，或用作终结点以创建具有多种用户类型设备的星形布局。 集线器包含多个端口，这些端口充当集线器与网络设备之间的输入/输出以太网连接。 集线器只能以一个速度运行，即网络上最慢网络设备的速度。 它不解释或筛选数据包，会将每个数据包的副本发送给所有连接的设备。</li>
<li>网桥<br>网桥会将网络划分为网段，可以在这些网段之间筛选和转发数据包。 网桥使用网络设备的 MAC 地址来决定数据包的目标。 通常使用网桥减少网段上不必要的网络流量，从而改善网络性能。</li>
<li>交换机<br>交换机合并了网桥和集线器的功能。 它会对网络进行分段，并且可以解释和筛选数据包数据，以将它直接发送给连接的网络设备。 交换机使用网络设备的 MAC 地址来决定数据包的目标。 交换机在全双工模式下运行，这意味着它可以同时向网络设备发送和从其接收数据。</li>
<li>路由器<br>路由器将具有不同范围地址的网络链接在一起。 它们可以解释和筛选数据包，然后将它们转发给正确的网络。 路由器使用网络设备的 IP 地址信息将数据包路由到其目标。 大多数路由器现在可以检测流向任何所连接网络的数据流量的问题，并路由或重新路由它以绕过问题。 路由器也称为网关。 配置网络设备时，通常会使用默认网关 IP 地址对它进行配置。</li>
</ul>
<p>几乎所有这些设备都依赖于媒体访问控制或 Internet 协议 (IP) 地址在网络上传递数据。</p>
<h4 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h4><p>网络协议是一组条件和规则，用于指定网络设备在给定网络上的通信方式。 它提供用于建立和维护信道，以及如何在发生错误或故障时进行处理的常用框架。 网络协议允许在启用网络的不同设备（例如笔记本电脑、平板电脑、智能手机、台式机、服务器和其他启用网络的设备）之间进行通信。</p>
<p>网络协议是组织的网络体系结构设计中的基本构建基块。 有很多可用的网络协议。 每种网络协议都具有许多控制其使用和实现的属性。</p>
<h4 id="协议类别"><a href="#协议类别" class="headerlink" title="协议类别"></a>协议类别</h4><p>多种类型的应用程序和硬件设备依赖于典型网络上的特定网络协议。 例如，使用 Web 浏览器浏览 Internet 所依赖的协议与发送或接收电子邮件不同。 转换在浏览器中看到的数据并通过网络发送此信息需要另一种协议。</p>
<p>协议分为三个类别：</p>
<ul>
<li>网络通信协议</li>
<li>网络安全协议</li>
<li>网络管理协议<br>我们来了解一下这些类别中的一些协议。</li>
</ul>
<h5 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h5><p>通信协议侧重于在设备之间建立和维护连接。 使用不同设备和网络服务时，你将使用各种网络通信协议。</p>
<p>首先，需要定义所有基于 Internet 的网络的三个基础协议。 这三个协议是传输控制协议 (TCP)、Internet 协议 (IP) 和用户数据报协议 (UDP)。 这些协议本身会处理网络上数据的逻辑传输。</p>
<ul>
<li><p>传输控制协议：TCP 是一种将数据分割为数据包的协议，数据包可以安全快速地发送，同时最大限度降低数据丢失的可能性。 它提供稳定可靠的机制，用于在基于 IP 的网络上传送数据包。 即使 TCP 是有效的面向连接的协议，它也有开销。</p>
</li>
<li><p>Internet 协议：IP 负责数据包的寻址。 IP 会封装要传递的数据包，并添加一个地址标头。 该标头包含发送方和接收方 IP 地址的信息。 该协议并不关心数据包的发送或接收顺序。 它也不保证会传送数据包，仅保证传送地址。</p>
</li>
<li><p>用户数据报协议：UDP 是一种无连接协议，可提供低延迟和丢失容忍实现。 UDP 用于无需验证接收方设备是否收到数据报的过程。<br>我们将在此处讨论的其余协议都基于某种类型的应用程序，例如，电子邮件客户端或 Web 浏览器。 下面是最常用网络通信协议：</p>
</li>
<li><p>超文本传输协议 (HTTP)：HTTP 协议使用 TCP/IP 将网页内容从服务器传递到浏览器。 HTTP 还可以处理从远程服务器进行的文件下载和上传。</p>
</li>
<li><p>文件传输协议 (FTP)：FTP 用于在网络上的不同计算机之间传输文件。 通常，FTP 用于从远程位置将文件上传到服务器。 虽然你可以使用 FTP 下载文件，不过基于 Web 的下载通常通过 HTTP 进行处理。</p>
</li>
<li><p>邮局协议 3 (POP3)：POP3 是三种电子邮件协议中的一种。 它最常由电子邮件客户端用于使你可以接收电子邮件。 此协议使用 TCP 进行电子邮件的管理和传递。</p>
</li>
<li><p>简单邮件传输协议 (SMTP)：SMTP 是三个电子邮件协议中的另一个。 它最常用于通过电子邮件服务器从电子邮件客户端发送电子邮件。 此协议使用 TCP 进行电子邮件的管理和传输。</p>
</li>
<li><p>交互式邮件访问协议 (IMAP)：IMAP 是这三种电子邮件协议中功能更强大的一种。 通过 IMAP 和电子邮件客户端，你便能在组织中的电子邮件服务器上管理单个邮箱。</p>
</li>
</ul>
<h5 id="网络安全协议"><a href="#网络安全协议" class="headerlink" title="网络安全协议"></a>网络安全协议</h5><p>网络安全协议旨在维护网络上数据的安全性和网络。 这些协议会加密在用户、服务和应用程序之间传输的消息。</p>
<p>网络安全协议使用加密和加密原则保护消息。</p>
<p>若要实现安全网络，必须匹配正确的安全协议以满足你的需求。 以下列表介绍了领先的网络安全协议：</p>
<ul>
<li>安全套接字层 (SSL)：SSL 是一种标准加密和安全协议。 它在计算机与你通过 Internet 访问的目标服务器或设备之间提供安全的加密连接。</li>
<li>传输层安全 (TLS)：TLS 是 SSL 的后继者，可提供更强、更牢靠的安全加密协议。 它基于 Internet 工程任务组 (ITEF) 标准，旨在阻止消息伪造以及篡改和窃听。 它通常用于保护 Web 浏览器通信、电子邮件、VoIP 和即时消息传递。 虽然现在使用 TLS，但替代安全协议通常仍称为 SSL。</li>
<li>安全超文本传输协议 (HTTPS)：HTTPS 使用 TLS 或 SSL 加密标准，提供标准 HTTP 协议的更多安全版本。 此协议组合可确保在服务器与 Web 浏览器之间传输的所有数据都进行加密，并防止窃听或数据包探查。 此原则同样适用于前面列出的 POP、SMTP 和 IMAP 协议，以创建称为 POPS、SMTPS 以及 IMAPS 的安全版本。</li>
<li>安全外壳 (SSH)：SSH 是一种加密网络安全协议，可在网络上提供安全数据连接。 SSH 旨在支持指令的命令行执行，包括对服务器的远程身份验证。 FTP 使用许多 SSH 功能来提供安全文件传输机制。</li>
<li>Kerberos：此验证协议通过密钥加密为基于客户端-服务器的应用程序提供可靠的身份验证。 Kerberos 假设网络中的所有端点都不安全。 它始终对所有通信和数据强制实施加密。</li>
</ul>
<h5 id="网络管理协议"><a href="#网络管理协议" class="headerlink" title="网络管理协议"></a>网络管理协议</h5><p>在你的网络中，同时运行多个不同的协议是完全可以接受的。 我们在前面讨论了通信和安全协议。 管理协议对于成功的网络日常运行和运营同样重要。 此类型协议的重点是网络的可持续性、了解错误和性能。</p>
<p>网络管理员需要监视其网络以及任何连接到它们的设备。 网络中的每个设备都会公开一些有关设备状态和运行状况的指示器。 这些指示器通过网络管理员工具进行请求，可以用于监视和报告。</p>
<p>有两种网络管理协议可用：</p>
<ul>
<li>简单网络管理协议 (SNMP)：SNMP 是一种网络协议，允许从网络上的设备收集数据以及管理这些设备。 设备必须支持 SNMP 才能收集信息。 通常支持 SNMP 的设备包括交换机、路由器、服务器、笔记本电脑、台式机和打印机。</li>
<li>Internet 控制消息协议 (ICMP)：ICMP 是 Internet 协议套件 (IPS) 中包含的协议之一。 它使连接网络的设备可以发送警告和错误消息，以及有关连接请求成功或失败或者服务是否不可用的操作信息。 与其他网络传输协议（如 UDP 和 TCP）不同，ICMP 不用于通过网络上的设备发送或接收数据。</li>
</ul>
<h3 id="IP-地址标准和服务"><a href="#IP-地址标准和服务" class="headerlink" title="IP 地址标准和服务"></a>IP 地址标准和服务</h3><h4 id="什么是地址解析协议？"><a href="#什么是地址解析协议？" class="headerlink" title="什么是地址解析协议？"></a>什么是地址解析协议？</h4><p>地址解析协议 (ARP) 是 Internet 协议套件中的一种通信协议。 这是一种请求-响应协议，用于解析给定 IP 地址的媒体访问控制 (MAC) 地址。 ARP 支持大量数据链路层技术，如 Internet 协议版本 4 (IPv4)、DECnet 和 PUP。 解析 Internet 协议版本 6 (IPv6) 地址时，将使用邻居发现协议 (NDP) 而不是 ARP。 如果没有 ARP，便无法将 IP 地址解析为物理设备地址。</p>
<p>还有反向地址识别协议 (RARP)，它会基于给定 MAC 地址检索 IP 地址。</p>
<h4 id="什么是-TCP-IP？"><a href="#什么是-TCP-IP？" class="headerlink" title="什么是 TCP/IP？"></a>什么是 TCP/IP？</h4><p>传输控制协议/Internet 协议是不同通信协议的集合，这些协议支持和定义启用网络的设备在基于 IP 的网络上的互连方式。 其核心是两个关键协议：TCP 和 IP。 TCP/IP 可实现 Internet 以及专用和公用网络（如 Intranet 和 Extranet）。</p>
<p>TCP/IP 通过定义端到端通信过程来定义在启用网络的设备之间共享数据的方式。 它管理消息如何细分为数据数据包（有时称为数据报）。 TCP/IP 还确定了如何对数据包进行寻址以及传输、路由和接收。 TCP/IP 可以确定网络上最高效的路由。</p>
<p>TCP/IP 模型设计为无状态。 此设计意味着网络堆栈会将每个请求视为新请求，因为它与上一个请求无关。 有一部分 TCP/IP 模型不是无状态的。 传输层在有状态模式下运行，因为它会维护连接，直到收到消息中的所有数据包。</p>
<p>TCP/IP 是一种开放标准。 它受到管理，但不属于任何一个组织，所以适用于所有操作系统、网络和硬件。</p>
<h5 id="TCP-IP-模型层"><a href="#TCP-IP-模型层" class="headerlink" title="#TCP/IP 模型层"></a>#TCP/IP 模型层</h5><p>TCP/IP 模型由四个不同的层组成。 每个层都使用不同类型的协议。 请注意 TCP/IP 模型与之前讨论的 Internet 协议套件的相似程度。</p>
<ul>
<li>应用程序层：应用程序层负责确定使用的通信协议。 此层包括超文本传输协议 (HTTP)、DNS、文件传输协议 (FTP)、Internet 消息访问协议 (IMAP)、轻型目录访问协议 (LDAP)、邮局协议 (POP)、简单邮件传输协议 (SMTP)、简单网络管理协议 (SNMP)、安全外壳 (SSH)、Telnet 和 TLS/SSL。</li>
<li>传输层：此层通过将正确端口用于所使用的应用程序协议，将应用程序数据拆分为可管理的有序区块。 与此层关联的协议是 TCP 和用户数据报协议 (UDP)。</li>
<li>Internet 层：此层也就是网络层，可确保数据包到达其目的地。 与此层关联的协议包括 IP、IPv4、IPv6、Internet 控制消息协议 (ICMP)，以及 Internet 协议安全性 (IPsec)。</li>
<li>网络访问层：此层负责定义跨网络发送数据的方式。 与此层关联的协议包括 ARP、MAC、以太网、数字用户线 (DSL)，以及综合业务数字网 (ISDN)。</li>
</ul>
<img src="/2020/07/15/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/WX20200715-203204@2x.png" class>




<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>内容均来自<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">Microsoft官方文档</a></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Azure 创建 VM</title>
    <url>/2020/07/15/%E4%BD%BF%E7%94%A8-Azure-%E5%88%9B%E5%BB%BA-VM/</url>
    <content><![CDATA[<h3 id="使用-Azure-创建-VM"><a href="#使用-Azure-创建-VM" class="headerlink" title="使用 Azure 创建 VM"></a>使用 Azure 创建 VM</h3><a id="more"></a>
<h3 id="在-Azure-中创建-Linux-虚拟机"><a href="#在-Azure-中创建-Linux-虚拟机" class="headerlink" title="在 Azure 中创建 Linux 虚拟机"></a>在 Azure 中创建 Linux 虚拟机</h3><h4 id="什么是-SSH？"><a href="#什么是-SSH？" class="headerlink" title="什么是 SSH？"></a>什么是 SSH？</h4><p>安全外壳 (SSH) 是一种加密的连接协议，它允许通过未受保护的连接进行安全登录。 通过 SSH，可以使用网络连接从远程位置连接到终端 shell。</p>
<p>有两种可用于对 SSH 连接进行身份验证的方法：用户名和密码，或 SSH 密钥对。</p>
<p>虽然 SSH 提供加密连接，但如果将密码用于 SSH 连接，VM 容易受到密码暴力破解攻击。 在使用 SSH 连接到 Linux VM 时，一种更安全且首选的方法是使用公钥/私钥对（也称为 SSH 密钥）。</p>
<p>凭借 SSH 密钥对，无需密码即可登录到基于 Linux 的 Azure 虚拟机。 如果只计划从多台计算机登录到 VM，这是一种更安全的方法。 如果需要能够从不同位置访问 Linux VM，结合使用用户名和密码可能是更好的方法。 SSH 密钥对有两个部分：公钥和私钥。</p>
<ul>
<li><p>公钥放置在 Linux VM 上或者要对其使用公钥加密的任何其他服务中。 公钥可与任何人共享。</p>
</li>
<li><p>“私钥”是在建立 SSH 连接时为验证身份向 Linux VM 呈现的内容。 请考虑此机密信息，并像保护密码或任何其他专用数据一样保护此信息。</p>
</li>
</ul>
<p>可使用同一个公钥/私钥对来访问多个 Azure VM 和服务。</p>
<h4 id="创建-SSH-密钥对"><a href="#创建-SSH-密钥对" class="headerlink" title="创建 SSH 密钥对"></a>创建 SSH 密钥对</h4><p>在 Linux、Windows 10 和 macOS 上，可使用内置的 ssh-keygen 命令来生成 SSH 公钥和私钥文件。</p>
<p>下面是为 Azure VM 生成密钥对所需的最低限度的命令。 此命令会创建一个 SSH 协议 2 (SSH-2) RSA 公钥-私钥对。 其最小长度为 2048 位，但对于本学习模块，我们将使用 4096 位的公钥-私钥对。</p>
<p>将此命令复制到 Cloud Shell 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure>

<p>选择 Enter 键以接受默认位置。 此命令会在 <code>~/.ssh</code> 目录中创建两个文件：<code>id_rsa</code> 和 <code>id_rsa.pub</code>。 如果文件已存在，则将其覆盖。</p>
<p>输入你会记住的密码。 使用 SSH 密钥访问 VM 时，需要使用此密码。</p>
<p>可以使用各种选项来提供文件名或密码，以避免出现提示。</p>
<h4 id="将-SSH-密钥对与-Azure-Linux-VM-一起使用"><a href="#将-SSH-密钥对与-Azure-Linux-VM-一起使用" class="headerlink" title="将 SSH 密钥对与 Azure Linux VM 一起使用"></a>将 SSH 密钥对与 Azure Linux VM 一起使用</h4><p>生成密钥对之后，可以将它与 Azure 中的 Linux VM 一起使用。 可以在创建 VM 期间提供公钥，也可以在创建 VM 后添加公钥。</p>
<p>可以通过以下命令在 Azure Cloud Shell 中查看文件的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<h4 id="将-SSH-密钥添加到现有的-Linux-VM"><a href="#将-SSH-密钥添加到现有的-Linux-VM" class="headerlink" title="将 SSH 密钥添加到现有的 Linux VM"></a>将 SSH 密钥添加到现有的 Linux VM</h4><p>如果已创建 VM，则可使用 ssh-copy-id 命令将公钥安装到 Linux VM 上。 一旦针对 SSH 授权该密钥后，它会在无需密码的情况下授予访问服务器的权限，但系统仍会提示提供密钥的通行短语（如果已设置）。</p>
<p>例如，如果有一个名为 myserver 的 Linux VM，它有一个名为 azureuser 的用户，可以使用以下命令安装公钥文件并使用密钥为用户授权：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub azureuser@myserver</span><br></pre></td></tr></table></figure>

<p>有了公钥后，我们便可切换到 Azure 门户并创建 Linux VM。</p>
<h4 id="新建-Linux-虚拟机"><a href="#新建-Linux-虚拟机" class="headerlink" title="新建 Linux 虚拟机"></a>新建 Linux 虚拟机</h4><p>可以使用 Azure 门户、Azure CLI 或 Azure PowerShell 创建 Linux VM。 开始使用 Azure 时，最简单的方法是使用门户，因为它会指导你完成所需的信息，并在创建过程中提供提示和有用的消息：</p>
<p>使用激活沙盒时所用的同一帐户登录到 Azure 门户 。</p>
<p>在 Azure 门户菜单上或在门户主页中，选择“创建资源”。</p>
<p>在搜索框中，输入“Ubuntu Server”。</p>
<p>从列表中选择“Ubuntu Server 18.04 LTS Canonical”。</p>
<p>单击“创建”按钮开始配置 VM。</p>
<h4 id="配置-VM-的磁盘"><a href="#配置-VM-的磁盘" class="headerlink" title="配置 VM 的磁盘"></a>配置 VM 的磁盘</h4><p>单击“下一步:磁盘&gt;”转到“磁盘”部分。</p>
<p>对于“OS 磁盘类型”，选择“高级 SSD”。</p>
<p>创建数据磁盘</p>
<h4 id="通过-SSH-连接到-VM"><a href="#通过-SSH-连接到-VM" class="headerlink" title="通过 SSH 连接到 VM"></a>通过 SSH 连接到 VM</h4><p>要通过 SSH 连接到 VM，需要：</p>
<ul>
<li>VM 的 公共 IP 地址</li>
<li>VM 上的本地帐户的用户名</li>
<li>在该帐户中配置的公钥</li>
<li>对相应的私钥的访问权限</li>
<li>在 VM 上打开端口 22</li>
</ul>
<p>之前，生成了 SSH 密钥对，并将公钥添加到 VM 配置中，并确保端口 22 已打开。</p>
<p>下一个单元将使用此信息，使用 SSH 在 VM 上打开安全终端。</p>
<p>终端打开后，可访问所有标准 Linux 命令行工具。</p>
<p>接下来，让我们使用 SSH 连接到 VM。</p>
<h4 id="使用-SSH-进行连接"><a href="#使用-SSH-进行连接" class="headerlink" title="使用 SSH 进行连接"></a>使用 SSH 进行连接</h4><p>首先需要获取 VM 的公共 IP 地址<br>在 Azure 门户 中，确保先前创建的虚拟机的“概述”面板已打开。 如果需要打开该 VM，可在“所有资源”下找到它。</p>
<h4 id="将命令从剪贴板粘贴到-Azure-Cloud-Shell。-删除-i-标志和私钥路径占位符。-它看起来应该类似于以下示例，但具有不同的-IP-地址和用户名："><a href="#将命令从剪贴板粘贴到-Azure-Cloud-Shell。-删除-i-标志和私钥路径占位符。-它看起来应该类似于以下示例，但具有不同的-IP-地址和用户名：" class="headerlink" title="将命令从剪贴板粘贴到 Azure Cloud Shell。 删除 -i 标志和私钥路径占位符。 它看起来应该类似于以下示例，但具有不同的 IP 地址和用户名："></a>将命令从剪贴板粘贴到 Azure Cloud Shell。 删除 -i 标志和私钥路径占位符。 它看起来应该类似于以下示例，但具有不同的 IP 地址和用户名：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh azureuser@13.68.150.164</span><br></pre></td></tr></table></figure>

<p>第一次连接时，SSH 将要求对未知的主机进行身份验证。 SSH 会告知你之前从未连接到此服务器过。 如果事实如此，那么完全正常；你可以回答“是”，从而将服务器的指纹保存在已知的主机文件中：</p>
<p>在适用于 Linux 的 shell 命令提示下，尝试执行几个 Linux 命令</p>
<ul>
<li>ls -la / 可显示磁盘根目录</li>
<li>ps -l 可显示所有正在运行的进程</li>
<li>dmesg 可列出所有内核消息</li>
<li>lsblk 可列出所有块设备- 此处将显示驱动器</li>
</ul>
<p>在驱动器列表中，可观察到的最有趣的一点是缺少的内容。 请注意，数据驱动器 (sdc) 存在，但未安装到文件系统中。 Azure 添加了一个 VHD，但未对其进行初始化。</p>
<h4 id="初始化数据磁盘"><a href="#初始化数据磁盘" class="headerlink" title="初始化数据磁盘"></a>初始化数据磁盘</h4><ol>
<li>首先，标识磁盘。 我们已在前面执行了此操作。 还可以使用 <code>dmesg | grep SCSI</code>，它将列出来自 SCSI 设备的内核的所有消息。</li>
<li>确定需要初始化的驱动器 <code>(sdc)</code> 后，可以使用 <code>fdisk</code> 执行此操作。 需要使用 <code>sudo</code> 运行命令，并提供要分区的磁盘。 可使用以下命令创建新的主分区:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">echo</span> n; <span class="built_in">echo</span> p; <span class="built_in">echo</span> 1; <span class="built_in">echo</span> ; <span class="built_in">echo</span> ; <span class="built_in">echo</span> w) | sudo fdisk /dev/sdc</span><br></pre></td></tr></table></figure></li>
<li>接下来，需要使用 mkfs 命令将文件系统写入该分区。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkfs -t ext4 /dev/sdc1`</span><br></pre></td></tr></table></figure></li>
<li>最后，需要将驱动器安装到文件系统中。 假定有一个 data 文件夹。 我们来创建装入点文件夹并安装驱动器。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir /data &amp;&amp; sudo mount /dev/sdc1 /data</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="将软件安装到-VM-上"><a href="#将软件安装到-VM-上" class="headerlink" title="将软件安装到 VM 上"></a>将软件安装到 VM 上</h4><h5 id="安装Apache-Web服务器"><a href="#安装Apache-Web服务器" class="headerlink" title="安装Apache Web服务器"></a>安装Apache Web服务器</h5><ol>
<li>首先，更新本地包索引以反映最新的上游更改：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li>
<li>接下来，安装 Apache：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apache2 -y</span><br></pre></td></tr></table></figure></li>
<li>它应自动启动 - 我们可使用 systemctl 检查状态：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl status apache2 --no-pager</span><br></pre></td></tr></table></figure>
<code>systemctl</code>  命令返回的内容如下所示：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apache2.service - The Apache HTTP Server</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/apache2.service; enabled; vendor preset: enabled)</span><br><span class="line">  Drop-In: /lib/systemd/system/apache2.service.d</span><br><span class="line">           └─apache2-systemd.conf</span><br><span class="line">   Active: active (running) since Mon 2018-09-03 21:00:03 UTC; 1min 34s ago</span><br><span class="line"> Main PID: 11156 (apache2)</span><br><span class="line">    Tasks: 55 (<span class="built_in">limit</span>: 4915)</span><br><span class="line">   CGroup: /system.slice/apache2.service</span><br><span class="line">           ├─11156 /usr/sbin/apache2 -k start</span><br><span class="line">           ├─11158 /usr/sbin/apache2 -k start</span><br><span class="line">           └─11159 /usr/sbin/apache2 -k start</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>-web-eus-vm1 systemd[1]: Starting The Apache HTTP Server...</span><br><span class="line"><span class="built_in">test</span>-web-eus-vm1 apachectl[11129]: AH00558: apache2: Could not reliably determine the server<span class="string">'s fully qua</span></span><br><span class="line"><span class="string">test-web-eus-vm1 systemd[1]: Started The Apache HTTP Server.</span></span><br></pre></td></tr></table></figure></li>
<li>最后，我们可以尝试通过公共 IP 地址检索默认页面。 但是，即使 Web 服务器在 VM 上运行，你也无法获得有效的连接或响应。<br>虚拟网络正在阻止入站请求。 我们可以通过配置对其进行更改。 接下来介绍允许入站请求。</li>
</ol>
<h4 id="在-Azure-VM-中打开端口"><a href="#在-Azure-VM-中打开端口" class="headerlink" title="在 Azure VM 中打开端口"></a>在 Azure VM 中打开端口</h4><p>默认情况下，新 VM 已被锁定。</p>
<p>应用可以发出传出请求，但唯一允许的入站流量来自于虚拟网络（如同一本地网络上的其他资源），并且来自于 Azure 负载均衡器（探测检查）。</p>
<p>分两步来调整配置，使其支持网络上的不同协议。 新建 VM 时，可打开几个常见端口（RDP、HTTP、HTTPS 和 SSH）。 但是，如果需要对防火墙进行其他更改，将需要手动进行调整。</p>
<p>此操作的过程包括两个步骤：</p>
<ol>
<li><p>创建网络安全组。</p>
</li>
<li><p>创建允许所需端口上的流量的入站规则。</p>
</li>
</ol>
<h4 id="更新网络接口上的-NSG"><a href="#更新网络接口上的-NSG" class="headerlink" title="更新网络接口上的 NSG"></a>更新网络接口上的 NSG</h4><p>端口 80 在应用于子网的 NSG 上打开。 但应用到网络接口的 NSG 阻止了 端口 80. 让我们解决这个问题，以便我们可以连接到网站。</p>
<ol>
<li><p>切换回虚拟机的“概览”面板。 可在“所有资源”下找到 VM。</p>
</li>
<li><p>在“设置”部分，选择“网络”项。</p>
</li>
<li><p>应该能在同一选项卡的上半部分看到子网的 NSG 规则，在下半部分看到网络接口的 NSG 规则。在下半部分，为网络接口的 NSG 规则选择“添加入站端口规则”。</p>
</li>
<li><p>选择“基本”。</p>
</li>
<li><p>对 HTTP 规则使用以下信息：</p>
</li>
<li><p>单击“添加”以创建规则。</p>
</li>
</ol>
<h5 id="打开默认网页"><a href="#打开默认网页" class="headerlink" title="打开默认网页"></a>打开默认网页</h5><p>使用服务器的 IP 地址发出 HTTP 请求。 它现在应正常工作。</p>
<h3 id="在-Azure-中创建-Windows-虚拟机"><a href="#在-Azure-中创建-Windows-虚拟机" class="headerlink" title="在 Azure 中创建 Windows 虚拟机"></a>在 Azure 中创建 Windows 虚拟机</h3><p>其实在 Azure 中创建 Windows VM 与 Linux VM 区别不是很大，首先选择的映像应该是 Windows Server， 有多个 Windows Server 版本可供选择。 在 Windows Server 映像概述面板中，单击“选择软件计划”下拉列表，并找到“Windows Server 2019 Datacenter”选项。</p>
<h4 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h4><p>在网络部分可能需要一些额外的配置</p>
<ol>
<li>生产系统中已有其他组件，我们希望使用现有的虚拟网络。 这样我们的 VM 就可与解决方案中的其他云服务进行通信。 如果此位置中尚未定义这样的网络，可在此处创建并配置：</li>
</ol>
<ul>
<li>地址空间：此网络可用的整体 IPV4 空间。</li>
<li>子网范围：首个细分地址空间的子网 - 必须适合定义的地址空间。 创建 VNet 后，就可以添加其他子网。</li>
</ul>
<ol start="2">
<li>让我们来更改默认范围，以使用 <code>172.xxx IP</code> 地址空间。 在“虚拟网络”下单击“新建”。</li>
</ol>
<ul>
<li>将“地址空间”字段更改为 <code>172.16.0.0/16</code>，以便为其提供完整的地址范围</li>
<li>将“子网范围”字段更改为 <code>172.16.1.0/24</code>，为其提供空间的 256 个 IP 地址。</li>
</ul>
<h4 id="使用-RDP-连接到-Windows-Azure-虚拟机"><a href="#使用-RDP-连接到-Windows-Azure-虚拟机" class="headerlink" title="使用 RDP 连接到 Windows Azure 虚拟机"></a>使用 RDP 连接到 Windows Azure 虚拟机</h4><p>远程桌面协议 (RDP) 提供到基于 Windows 的计算机 UI 的远程连接。 使用 RDP，可以登录到远程物理或虚拟 Windows 计算机，并像处于控制台一样控制该计算机。 通过 RDP 连接，可以从物理计算机的控制台执行大部分操作，某些电源和硬件相关的功能除外。</p>
<p>RDP 连接需要 RDP 客户端。 Microsoft 为以下操作系统提供 RDP 客户端：</p>
<ul>
<li>Windows（内置）</li>
<li>macOS</li>
<li>iOS</li>
<li>Android</li>
</ul>
<p>我使用的是 Microsoft 官方提供的 MacOS 使用的 Microsoft Remote Desktop 软件。<br>使用 RDP 连接到 Azure 中的 VM 是一个简单的过程。 在 Azure 门户中，转到 VM 的属性，然后单击顶部的“连接”。 这会显示分配到 VM 的 IP 地址，并可选择下载 Windows 稍后在 RDP 客户端中打开的 preconfigured.rdp 文件。<br>下载之后使用 Microsoft Remote Desktop 打开 rdp 文件就可以进行远程连接</p>
<h4 id="初始化数据磁盘-1"><a href="#初始化数据磁盘-1" class="headerlink" title="初始化数据磁盘"></a>初始化数据磁盘</h4><p>同样的，新创建的 Windows VM 也需要进行数据磁盘的初始化。</p>
<p>将需要初始化和格式化从头开始创建的任何其他驱动器。 执行此操作的过程与对物理驱动器执行的操作过程相同。</p>
<ol>
<li><p>从“开始”菜单启动“磁盘管理”工具。 你可能需要先转到计算机管理工具，然后转到“磁盘管理”，或尝试在“开始”菜单中搜索“磁盘管理”。</p>
</li>
<li><p>此时会显示一条警告，指示检测到未初始化的磁盘。</p>
</li>
<li><p>单击“确定”初始化该磁盘。 该磁盘随即显示在卷列表中，可将其格式化并分配驱动器号。</p>
</li>
<li><p>打开文件资源管理器，此时应会看到数据驱动器。</p>
</li>
<li><p>继续操作并关闭 RDP 客户端，以从 VM 注销。 服务器将继续运行。</p>
</li>
</ol>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>内容均来自<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">Microsoft官方文档</a></p>
]]></content>
      <categories>
        <category>Azure</category>
      </categories>
      <tags>
        <tag>Azure</tag>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>Azure 体系结构和服务保证</title>
    <url>/2020/07/14/Azure-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%8D%E5%8A%A1%E4%BF%9D%E8%AF%81/</url>
    <content><![CDATA[<h3 id="Azure基础知识：核心云服务"><a href="#Azure基础知识：核心云服务" class="headerlink" title="Azure基础知识：核心云服务"></a>Azure基础知识：核心云服务</h3><a id="more"></a>
<h3 id="Azure-体系结构和服务保证"><a href="#Azure-体系结构和服务保证" class="headerlink" title="Azure 体系结构和服务保证"></a>Azure 体系结构和服务保证</h3><h4 id="Azure-中的地域"><a href="#Azure-中的地域" class="headerlink" title="Azure 中的地域"></a>Azure 中的地域</h4><p>Azure 将世界划分为由地缘政治边界或国家/地区边界定义的多个地域。 一个 Azure 地域代表一个独立市场，通常包含两个或更多个设有数据驻留和合规性边界的区域。 这种划分方式具有以下几个优点。</p>
<ul>
<li>地域使具有特定数据驻留和合规性要求的客户可将其数据和应用程序部署在距离其较近的位置。</li>
<li>地域保证数据驻留、主权、合规性和复原能力的要求在地域边界内得到满足。</li>
<li>通过与专用的高容量网络基础设施相连，地域具有容错能力，可承受整个区域的故障。</li>
</ul>
<h4 id="什么是区域？"><a href="#什么是区域？" class="headerlink" title="什么是区域？"></a>什么是区域？</h4><p>区域是指地球上的某个地理区域，包含至少一个（但很可能是多个）数据中心，这些数据中心彼此相邻并通过一个低延迟的网络相互连接。 Azure 智能地分配和控制每个区域内的资源，以确保适当平衡工作负载。<br>每个区域只属于某一个地域，并应用有特定的服务可用性、合规性以及数据驻留/主权规则。</p>
<h4 id="什么是可用性区域？"><a href="#什么是可用性区域？" class="headerlink" title="什么是可用性区域？"></a>什么是可用性区域？</h4><p>可用性区域是 Azure 区域中的物理上独立的数据中心。</p>
<h4 id="什么是区域对？"><a href="#什么是区域对？" class="headerlink" title="什么是区域对？"></a>什么是区域对？</h4><p>在同一地域（例如美国、欧洲或亚洲）内，每个 Azure 区域始终与至少距其 300 英里外的另一区域配对。 此方法适用于跨地域复制资源（例如虚拟机存储），有助于减少因自然灾害、社会动乱、电力中断或物理网络中断等事件（同时影响两个区域）造成服务中断的可能性。 例如，如果一个区域对中的某个区域受到自然灾害，则服务会自动故障转移到其区域对中的其他区域。</p>
<h4 id="Azure-的服务级别协议"><a href="#Azure-的服务级别协议" class="headerlink" title="Azure 的服务级别协议"></a>Azure 的服务级别协议</h4><p>Microsoft 通过遵守全面的运营策略、标准和做法，坚持不懈地致力于为客户提供高质量的产品和服务。 名为服务级别协议 (SLA) 的正式文档涵盖了许多特定术语，这些术语定义了适用于 Azure 的性能标准。</p>
<ul>
<li>SLA 描述 Microsoft 为 Azure 客户提供特定性能标准的承诺。</li>
<li>各个 Azure 产品和服务都有相对应的 SLA。</li>
<li>SLA 还规定当服务或产品无法履行适用 SLA 的规范时会发生什么情况。</li>
</ul>
<h3 id="有关-Azure-计算的基本概念"><a href="#有关-Azure-计算的基本概念" class="headerlink" title="有关 Azure 计算的基本概念"></a>有关 Azure 计算的基本概念</h3><h4 id="什么是-Azure-计算？"><a href="#什么是-Azure-计算？" class="headerlink" title="什么是 Azure 计算？"></a>什么是 Azure 计算？</h4><p>Azure 计算是一种按需计算服务，用于运行基于云的应用程序。 它通过虚拟机和容器提供多核处理器和超级计算机等计算资源。 它还提供无服务器计算，无需设置或配置基础结构即可运行应用。 资源按需提供，通常可在几分钟甚至几秒内创建。 只需为使用的资源付费，并且只在使用它们时付费。</p>
<p>有四种用于在 Azure 中执行计算的常用技术：</p>
<ul>
<li>虚拟机</li>
<li>容器</li>
<li>Azure应用服务</li>
<li>无服务器计算</li>
</ul>
<h4 id="什么是虚拟机？"><a href="#什么是虚拟机？" class="headerlink" title="什么是虚拟机？"></a>什么是虚拟机？</h4><p>虚拟机 (VM) 是物理计算机的软件模拟。 它们包括虚拟处理器、内存、存储和网络资源。 它们托管一个操作系统 (OS)，用户可以像使用物理计算机一样安装和运行软件。 使用远程桌面客户端可以像坐在终端前面一样使用和控制虚拟机。</p>
<h4 id="什么是容器？"><a href="#什么是容器？" class="headerlink" title="什么是容器？"></a>什么是容器？</h4><p>容器是用于运行应用程序的虚拟化环境。 与虚拟机一样，容器也在主机操作系统上运行。 但与 VM 不同，容器不包含在容器内部运行的应用的操作系统。 相反，容器将捆绑运行应用程序所需的库和组件，并使用运行该容器的现有主机操作系统。 例如，如果有五个容器在具有特定 Linux 内核的服务器上运行，则所有五个容器以及其中的应用都共享同一 Linux 内核。</p>
<h4 id="什么是-Azure-应用服务？"><a href="#什么是-Azure-应用服务？" class="headerlink" title="什么是 Azure 应用服务？"></a>什么是 Azure 应用服务？</h4><p>Azure 应用服务是 Azure 中的平台即服务 (PaaS) 产品/服务，为托管面向 Web 的企业级应用程序而设计。 在使用完全托管的平台执行基础结构维护的同时，可以满足严苛的性能、可伸缩性、安全性和合规性要求。</p>
<h4 id="什么是无服务器计算？"><a href="#什么是无服务器计算？" class="headerlink" title="什么是无服务器计算？"></a>什么是无服务器计算？</h4><p>无服务器计算是一个云托管执行环境，可运行代码，但是将基础托管环境完全抽象化。 创建该服务的实例以及添加代码，无需甚至不允许配置或维护基础结构。</p>
<h3 id="Azure-数据存储选项"><a href="#Azure-数据存储选项" class="headerlink" title="Azure 数据存储选项"></a>Azure 数据存储选项</h3><h4 id="使用-Azure-来存储数据的优势"><a href="#使用-Azure-来存储数据的优势" class="headerlink" title="使用 Azure 来存储数据的优势"></a>使用 Azure 来存储数据的优势</h4><p>以下是 Azure 数据存储的一些重要优势：</p>
<ul>
<li>自动备份和恢复：减轻发生任何意外故障或中断时丢失数据的风险。</li>
<li>在全球范围内复制：复制数据，防止出现任何计划内或计划外事件（例如计划性维护或硬件故障）。 可选择在全球多个位置复制数据。</li>
<li>支持数据分析：支持对数据使用情况进行分析。</li>
<li>加密功能：对数据加密，使之十分安全；也可对能够访问数据的人员进行严格控制。</li>
<li>多种数据类型：Azure 几乎可以存储所需的任何类型的数据。 它可以处理视频文件、文本文件甚至虚拟硬盘等大型二进制文件。 它还为关系数据和 NoSQL 数据提供了多种选项。</li>
<li>虚拟磁盘中的数据存储：Azure 还可在其虚拟磁盘中存储多达 32 TB 的数据。 在存储大量数据（例如视频和模拟）时，该功能非常重要。</li>
<li>存储层：存储层可根据信息的使用频率来确定数据访问的优先级。</li>
</ul>
<p>数据类型<br>Azure 存储旨在保存三种主要类型的数据。</p>
<ol>
<li>结构化数据。 结构化数据是遵循某种架构的数据，因此所有数据都具有相同的字段或属性。 结构化数据可以存储在具有行和列的数据库表中。 结构化数据通过键来指示表中的一行数据与另一表中的另一行数据的关系。 结构化数据也称为关系数据，因为数据的架构定义了数据表和表中的字段以及两者之间的明确关系。 结构化数据很简单，易于输入、查询和分析。 所有数据都遵循相同的格式。 结构化数据的示例包括传感器数据或财务数据。</li>
<li>半结构化数据。 半结构化数据不太适合放入表、行和列， 而是使用_标记<em>或</em>键_来整理数据并为其提供层次结构。 半结构化数据也称为非关系数据或 NoSQL 数据。</li>
<li>非结构化数据。 非结构化数据包含没有指定结构的数据。 结构的缺失意味着它可以保存任何数据的类型。 例如，blob 可以保存 PDF 文档、JPG 图像、JSON 文件和视频内容等等。因此，随着企业不断尝试挖掘新的数据源，非结构化数据也变得越来越重要。</li>
</ol>
<h4 id="Azure-数据存储和本地存储之间的比较"><a href="#Azure-数据存储和本地存储之间的比较" class="headerlink" title="Azure 数据存储和本地存储之间的比较"></a>Azure 数据存储和本地存储之间的比较</h4><p>将本地数据与 Azure 数据存储进行比较时，需要考虑几个因素。</p>
<ul>
<li>成本效益</li>
<li>可靠性</li>
<li>存储类型</li>
<li>敏捷性</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>内容均来自<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">Microsoft官方文档</a></p>
]]></content>
      <categories>
        <category>Azure</category>
      </categories>
      <tags>
        <tag>Azure</tag>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算的概念</title>
    <url>/2020/07/14/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h3 id="Azure基础知识：云概念-云计算的原则"><a href="#Azure基础知识：云概念-云计算的原则" class="headerlink" title="Azure基础知识：云概念 - 云计算的原则"></a>Azure基础知识：云概念 - 云计算的原则</h3><a id="more"></a>
<h4 id="什么是云计算"><a href="#什么是云计算" class="headerlink" title="什么是云计算"></a>什么是云计算</h4><p>云计算是指通过 Internet 提供的、使用即用即付定价模式的计算服务。 换句话说，它是一种从其他人的数据中心租用计算能力和存储的方法。</p>
<h4 id="云计算的优势"><a href="#云计算的优势" class="headerlink" title="云计算的优势"></a>云计算的优势</h4><p>云计算让经营企业变得更加轻松。 云计算经济高效、可缩放、具有弹性、始终保持最新状态、可靠且安全。 这意味着你可以将更多时间花在重要事项上，而只需花较少时间来管理基础细节。</p>
<h4 id="规模效益"><a href="#规模效益" class="headerlink" title="规模效益"></a>规模效益</h4><p>规模效益是指大规模运作时，能够较高效地或以较低的单位成本完成任务。 这种成本优势是云计算的一个重要优势。</p>
<h4 id="资本支出-CapEx-与运营支出-OpEx"><a href="#资本支出-CapEx-与运营支出-OpEx" class="headerlink" title="资本支出 (CapEx) 与运营支出 (OpEx)"></a>资本支出 (CapEx) 与运营支出 (OpEx)</h4><ul>
<li>资本支出 (CapEx)：CapEx 是预先将资金花在实体基础设施上，然后逐渐从税单中扣除这笔费用。 CapEx 是一种前期成本，其价值会随着时间的推移而降低。</li>
</ul>
<ol>
<li>服务器成本</li>
<li>存储成本</li>
<li>网络成本</li>
<li>备份和存档的成本</li>
<li>组织连续性和灾难恢复成本</li>
<li>数据中心基础设施成本</li>
<li>技术人员</li>
</ol>
<ul>
<li>运营支出 (OpEx)：OpEx 是现在花钱购买服务或产品，现在为其付费。 可以在同一年从税单中扣除此项费用。 无前期成本。 你可以在使用服务或产品时为其付费。</li>
</ul>
<ol>
<li>租用软件和自定义功能</li>
<li>根据使用/需求而不是固定硬件或容量来缩减费用</li>
<li>在用户或组织级别计费</li>
</ol>
<h4 id="云计算的三种部署方法"><a href="#云计算的三种部署方法" class="headerlink" title="云计算的三种部署方法"></a>云计算的三种部署方法</h4><p>公有云、私有云和混合云</p>
<h4 id="云服务的类型"><a href="#云服务的类型" class="headerlink" title="云服务的类型"></a>云服务的类型</h4><ul>
<li>基础结构即服务 (IaaS)</li>
<li>平台即服务 (PaaS)</li>
<li>软件即服务 (SaaS)<br>管理职责<img src="/2020/07/14/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E6%A6%82%E5%BF%B5/2020-07-14-%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E6%A6%82%E5%BF%B5.png" class>
<img src="/2020/07/14/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E6%A6%82%E5%BF%B5/WX20200714-233003@2x.png" class>



</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>内容均来自<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">Microsoft官方文档</a></p>
]]></content>
      <categories>
        <category>Azure</category>
      </categories>
      <tags>
        <tag>Azure</tag>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex</title>
    <url>/2020/02/03/Vuex/</url>
    <content><![CDATA[<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><a id="more"></a>
<p>打开终端 安装Vuex</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> vuex</span><br></pre></td></tr></table></figure>
<p>导入vuex<br>在index.js文件中<code>import Vuex from &#39;vuex&#39;</code><br><code>Vue.use(vuex)</code></p>
<p>写一个简单的例子</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">export <span class="keyword">default</span> new Vuex.Store(&#123;</span><br><span class="line">  <span class="keyword">state</span>: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (<span class="keyword">state</span>) &#123;</span><br><span class="line">      <span class="keyword">state</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit('increment')</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在main.js里引入</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br></pre></td></tr></table></figure>

<p>启动项目</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> serve</span></span><br></pre></td></tr></table></figure>
<p>打开项目首页 大功告成！<br><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli构建Vue项目</title>
    <url>/2020/02/03/Vue-cli%E6%9E%84%E5%BB%BAVue%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h3 id="Vue-cli构建Vue项目"><a href="#Vue-cli构建Vue项目" class="headerlink" title="Vue-cli构建Vue项目"></a>Vue-cli构建Vue项目</h3><a id="more"></a>
<h5 id="创建新的Vue项目"><a href="#创建新的Vue项目" class="headerlink" title="创建新的Vue项目"></a>创建新的Vue项目</h5><figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">vue</span> <span class="variable">init</span> <span class="variable">webpack</span> <span class="function"><span class="title">vue01</span>(项目名)</span></span><br></pre></td></tr></table></figure>
<ol>
<li>按回车确认项目名或者在光标处修改，项目名不能以大写字母开头，不能包含特殊字符。</li>
<li>项目描述 可以输入也可以直接回车确认</li>
<li>作者 可以输入也可以直接回车确认</li>
<li>项目创建方式 可以选择运行+编译或者运行</li>
<li>是否安装vue-router 可以添加也可以在之后再手动添加</li>
<li>是否添加ESlint 可以添加也可以不添加</li>
<li>设置单元测试 可以添加也可以不添加</li>
<li>e2e测试 可以添加也可以不添加</li>
<li>是否需要运行npm或者yarn 可以运行也可以不运行</li>
</ol>
<p>创建好之后cd到项目目录里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> vue01/</span><br></pre></td></tr></table></figure>
<p>然后手动npm install</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> dev</span></span><br></pre></td></tr></table></figure>
<h5 id="使用Vue-cli创建Vue项目"><a href="#使用Vue-cli创建Vue项目" class="headerlink" title="使用Vue-cli创建Vue项目"></a>使用Vue-cli创建Vue项目</h5><p>打开终端 安装Vue-cli</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g @vue/cli</span><br></pre></td></tr></table></figure>
<p>查看版本</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">vue <span class="comment">--version</span></span><br></pre></td></tr></table></figure>
<p>创建项目</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">vue</span> <span class="variable">create</span> <span class="function"><span class="title">vue01</span>(项目名)</span></span><br></pre></td></tr></table></figure>
<ol>
<li>选择编译工具</li>
<li>router是否使用历史模式</li>
<li>想在哪里配置</li>
<li>是否保存为模版</li>
</ol>
<p>启动项目</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> serve</span></span><br></pre></td></tr></table></figure>
<p>打开项目首页 大功告成！<br><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity登录表单配置</title>
    <url>/2020/01/07/SpringSecurity%E7%99%BB%E5%BD%95%E8%A1%A8%E5%8D%95%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="SpringSecurity登录表单配置"><a href="#SpringSecurity登录表单配置" class="headerlink" title="SpringSecurity登录表单配置"></a>SpringSecurity登录表单配置</h3><a id="more"></a>
<h4 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h4><h5 id="1-登录成功"><a href="#1-登录成功" class="headerlink" title="1.登录成功"></a>1.登录成功</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     http.authorizeRequests()</span><br><span class="line">     .and()</span><br><span class="line">     .formLogin()</span><br><span class="line">     .usernameParameter(<span class="string">"username"</span>)</span><br><span class="line">     .passwordParameter(<span class="string">"password"</span>)</span><br><span class="line">     .loginProcessingUrl(<span class="string">"/doLogin"</span>)</span><br><span class="line">     .loginPage(<span class="string">"/login"</span>)</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     登录成功的回调</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">     .successHandler(<span class="keyword">new</span> AuthenticationSuccessHandler() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span></span></span><br><span class="line"><span class="function">                 <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                 resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                 PrintWriter out = resp.getWriter();</span><br><span class="line">                 Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                 map.put(<span class="string">"status"</span>, <span class="number">200</span>);</span><br><span class="line">                 map.put(<span class="string">"msg"</span>, authentication.getPrincipal());</span><br><span class="line">                 out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(map));</span><br><span class="line">                 out.flush();</span><br><span class="line">                 out.close();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;)</span><br></pre></td></tr></table></figure>
<h5 id="2-登录失败"><a href="#2-登录失败" class="headerlink" title="2.登录失败"></a>2.登录失败</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.failureHandler(<span class="keyword">new</span> AuthenticationFailureHandler() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException exception)</span></span></span><br><span class="line"><span class="function">                       <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                           resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                           PrintWriter out = resp.getWriter();</span><br><span class="line">                           Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                           map.put(<span class="string">"status"</span>, <span class="number">401</span>);</span><br><span class="line">                           <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> LockedException)&#123;</span><br><span class="line">                               map.put(<span class="string">"msg"</span>, <span class="string">"账户被锁定，请联系管理员!"</span>);</span><br><span class="line">                           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> CredentialsExpiredException)&#123;</span><br><span class="line">                               map.put(<span class="string">"msg"</span>, <span class="string">"密码过期，请联系管理员!"</span>);</span><br><span class="line">                           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> AccountExpiredException)&#123;</span><br><span class="line">                               map.put(<span class="string">"msg"</span>, <span class="string">"账户过期，请联系管理员!"</span>);</span><br><span class="line">                           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> DisabledException)&#123;</span><br><span class="line">                               map.put(<span class="string">"msg"</span>, <span class="string">"账户被禁用，请联系管理员!"</span>);</span><br><span class="line">                           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> BadCredentialsException)&#123;</span><br><span class="line">                               map.put(<span class="string">"msg"</span>, <span class="string">"用户名或者密码输入错误，请重新输入!"</span>);</span><br><span class="line">                           &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                           	map.put(<span class="string">"msg"</span>, <span class="string">"登录失败!"</span>)</span><br><span class="line">                           &#125; </span><br><span class="line">                           out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(map));</span><br><span class="line">                           out.flush();</span><br><span class="line">                           out.close();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;)</span><br></pre></td></tr></table></figure>
<h5 id="3-注销"><a href="#3-注销" class="headerlink" title="3.注销"></a>3.注销</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.logout()</span><br><span class="line">.logoutUrl(<span class="string">"/logout"</span>)</span><br><span class="line">            .logoutSuccessHandler(<span class="keyword">new</span> LogoutSuccessHandler() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLogoutSuccess</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                    resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                    PrintWriter out = resp.getWriter();</span><br><span class="line">                    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    map.put(<span class="string">"status"</span>, <span class="number">200</span>);</span><br><span class="line">                    map.put(<span class="string">"msg"</span>, <span class="string">"注销成功!"</span>)</span><br><span class="line">                    out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(map));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable().exceptionHandling()</span><br></pre></td></tr></table></figure>
<h5 id="4-方法安全"><a href="#4-方法安全" class="headerlink" title="4.方法安全"></a>4.方法安全</h5><p>SpringSecurity中默认默认禁用注解，要想开启注解，需要在继承WebSecurityConfigurerAdapter的类上加@EnableGlobalMethodSecurity注解，并在该类中将AuthenticationManager定义为bean。<br>在SpringSecurity配置类上加上注解<code>@EnableGlobalMethodSecurity</code><br>里面有几个属性:</p>
<ol>
<li>prePostEnable注解: <code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code></li>
<li>@PreAuthorize：在方法执行前判断，可以调用方法参数，主要利用Java8的参数名反射特性，如果没用Java8也可以使用spring security的@P标注参数，或者Spring Data的@Param标注参数。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断用户是否为当前登录用户或拥有ROLE_ADMIN权限</span></span><br><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"#userId == authentication.principal.userId or hasAuthority(‘ADMIN’)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changePassword</span><span class="params">(@P(<span class="string">"userId"</span>)</span> <span class="keyword">long</span> userId )</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>@PostAuthorize：在方法执行后判断，可以调用参数。如果EL为false，虽然方法已经执行完了也可能会回滚，EL变量returnObject表示返回的对象。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostAuthorize</span></span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(<span class="string">"returnObject.userId == authentication.principal.userId or hasPermission(returnObject, 'ADMIN')"</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>@PreFilter:在方法执行前判断，可以调用方法参数，对参数值进行过滤、处理或修改。EL变量filterObject表示参数，如有多个参数则用filterTarget注解参数，那么参数必须是集合或数组才行（很少用到，与分页技术不兼容）。</li>
<li>securedEnable注解: @Secured:是否有权限访问 <code>@EnableGlobalMethodSecurity(securedEnabled = true)</code><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Secured(<span class="meta-string">"IS_AUTHENTICATED_ANONYMOUSLY"</span>)</span> <span class="keyword">public</span> Account readAccount(<span class="built_in">Long</span> id);</span><br><span class="line"><span class="meta">@Secured(<span class="meta-string">"ROLE_TELLER"</span>)</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity基础</title>
    <url>/2020/01/05/SpringSecurity%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="SpringSecurity基础"><a href="#SpringSecurity基础" class="headerlink" title="SpringSecurity基础"></a>SpringSecurity基础</h3><a id="more"></a>
<h4 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h4><h5 id="1-项目创建"><a href="#1-项目创建" class="headerlink" title="1. 项目创建"></a>1. 项目创建</h5><p>在 Spring Boot 中使用 Spring Security 非常容易，引入依赖即可：</p>
<img src="/2020/01/05/SpringSecurity%E5%9F%BA%E7%A1%80/WX20200105-191217@2x.png" class>
<p>pom.xml 中的 Spring Security 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只要加入依赖，项目的所有接口都会被自动保护起来。</p>
<h5 id="2-初次体验"><a href="#2-初次体验" class="headerlink" title="2. 初次体验"></a>2. 初次体验</h5><p>创建一个HelloController:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello Security!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问<code>/hello</code>，需要登录之后才能访问。</p>
<h5 id="3-用户名配置"><a href="#3-用户名配置" class="headerlink" title="3. 用户名配置"></a>3. 用户名配置</h5><p>默认情况下，登录的用户名是<code>user</code>,密码则是项目启动时随机生成的字符串，可以从启动的控制台日志中看到默认密码：<br>这个随机生成的密码，每次启动时都会变。对登录的用户名/密码进行配置，有三种不同的方式：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">在 application.properties 中进行配置</span><br><span class="line">通过 <span class="keyword">Java </span>代码配置在内存中</span><br><span class="line">通过 <span class="keyword">Java </span>从数据库中加载</span><br></pre></td></tr></table></figure>
<h5 id="3-1-配置文件配置用户名-密码"><a href="#3-1-配置文件配置用户名-密码" class="headerlink" title="3.1 配置文件配置用户名/密码"></a>3.1 配置文件配置用户名/密码</h5><p>可以直接在 application.properties 文件中配置用户的基本信息：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">spring.<span class="keyword">security</span>.<span class="keyword">user</span>.name=dubowen</span><br><span class="line">spring.<span class="keyword">security</span>.<span class="keyword">user</span>.<span class="keyword">password</span>=<span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>配置完成后，重启项目，就可以使用这里配置的用户名/密码登录了。</p>
<h5 id="3-2-Java-配置用户名-密码"><a href="#3-2-Java-配置用户名-密码" class="headerlink" title="3.2 Java 配置用户名/密码"></a>3.2 Java 配置用户名/密码</h5><p>也可以在 Java 代码中配置用户名密码，首先需要我们创建一个 Spring Security 的配置类，集成自 WebSecurityConfigurerAdapter 类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="string">"admin"</span>).roles(<span class="string">"admin"</span>).password(<span class="string">"123"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">"dubowen"</span>).roles(<span class="string">"user"</span>).password(<span class="string">"123"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们在 configure 方法中配置了两个用户，用户的密码都是加密之后的字符串(明文是 123)，从 Spring5 开始，强制要求密码要加密，如果非不想加密，可以使用一个过期的 PasswordEncoder 的实例 NoOpPasswordEncoder，但是不建议这么做，毕竟不安全。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> NoOpPasswordEncoder.<span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Spring Security 中提供了 BCryptPasswordEncoder 密码编码工具，可以非常方便的实现密码的加密加盐，相同明文加密出来的结果总是不同，这样就不需要用户去额外保存 盐的字段了，这一点比 Shiro 要方便很多。</p>
<h5 id="4-登录配置"><a href="#4-登录配置" class="headerlink" title="4.登录配置"></a>4.登录配置</h5><p>对于登录接口，登录成功后的响应，登录失败后的响应，我们都可以在 WebSecurityConfigurerAdapter 的实现类中进行配置。例如下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         http.authorizeRequests()</span><br><span class="line">                 <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 开启配置</span></span><br><span class="line"><span class="comment">                 所有请求的认证之后才可以访问</span></span><br><span class="line"><span class="comment">                  */</span></span><br><span class="line">                 .antMatchers(<span class="string">"/admin/**"</span>).hasRole(<span class="string">"admin"</span>)</span><br><span class="line">                 .antMatchers(<span class="string">"user/**"</span>).hasAnyRole(<span class="string">"admin"</span>,<span class="string">"user"</span>)</span><br><span class="line">                 <span class="comment">//登录之后就能访问</span></span><br><span class="line">                 .anyRequest().authenticated()</span><br><span class="line">                 .and()</span><br><span class="line">                 .formLogin()</span><br><span class="line">                 <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 登录处的url和登录页面</span></span><br><span class="line"><span class="comment">                  */</span></span><br><span class="line">                 .loginProcessingUrl(<span class="string">"/doLogin"</span>)</span><br><span class="line">                 .permitAll()</span><br><span class="line">                 .and()</span><br><span class="line">                 .csrf.disable();</span><br><span class="line">                 </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/amdin/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">admin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello admin!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello user!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-忽略拦截"><a href="#5-忽略拦截" class="headerlink" title="5. 忽略拦截"></a>5. 忽略拦截</h5><p>如果某一个请求地址不需要拦截的话，有两种方式实现：</p>
<ol>
<li>设置该地址匿名访问</li>
<li>直接过滤掉该地址，即该地址不走 Spring Security 过滤器链</li>
</ol>
<p>推荐使用第二种方案，配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        web.ignoring().antMatchers(<span class="string">"/login"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot配置文件和静态资源</title>
    <url>/2019/12/25/SpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%92%8C%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h3 id="SpringBoot配置文件和静态资源的存放位置和加载顺序"><a href="#SpringBoot配置文件和静态资源的存放位置和加载顺序" class="headerlink" title="SpringBoot配置文件和静态资源的存放位置和加载顺序"></a>SpringBoot配置文件和静态资源的存放位置和加载顺序</h3><a id="more"></a>
<h4 id="SpringBoot加载配置文件优先级顺序"><a href="#SpringBoot加载配置文件优先级顺序" class="headerlink" title="SpringBoot加载配置文件优先级顺序"></a>SpringBoot加载配置文件优先级顺序</h4><p>SpringBoot启动会扫描以下位置的application.properties或者application.yml作为默认的配置文件</p>
<ol>
<li>工程根目录:./config/</li>
<li>工程根目录:./</li>
<li>classpath:/config/</li>
<li>classpath:/</li>
</ol>
<p>加载的优先级顺序是从上向下加载，并且所有的文件都会被加载，高优先级的内容会覆盖掉优先级低的内容，形成互补配置。<br>注: </p>
<ol>
<li>如果同一个目录下，有application.yml也有application.properties，默认先读取application.properties。</li>
<li>如果同一个配置属性，在多个配置文件都配置了，默认使用第1个读取到的，后面读取的不覆盖前面读取到的。</li>
<li>创建SpringBoot项目时，一般的配置文件放置在项目的resources目录下，因为配置文件的修改，通过热部署不用重新启动项目，而热部署的作用范围是classpath下</li>
</ol>
<h4 id="配置随机值"><a href="#配置随机值" class="headerlink" title="配置随机值"></a>配置随机值</h4><p>roncoo.secret={random.value} roncoo.number={random.int}<br>roncoo.bignumber={random.long} roncoo.number.less.than.ten={random.int(10)}<br>roncoo.number.in.range=${random.int[1024,65536]}<br>读取使用注解：@Value(value = “${roncoo.secret}”)<br>注：出现黄点提示，是要提示配置元数据，可以不配置</p>
<h4 id="其他配置的介绍"><a href="#其他配置的介绍" class="headerlink" title="其他配置的介绍"></a>其他配置的介绍</h4><p>端口配置<br>server.port=8080<br>时间格式化<br>spring.jackson.date-format=yyyy-MM-dd HH:mm:ss<br>时区设置<br>spring.jackson.time-zone=Asia/Shanghai</p>
<h4 id="SpringBoot加载静态资源优先级顺序"><a href="#SpringBoot加载静态资源优先级顺序" class="headerlink" title="SpringBoot加载静态资源优先级顺序"></a>SpringBoot加载静态资源优先级顺序</h4><p>在SpringBoot中，新创建的项目中，资源默认都会存放在resources/static目录。<br>在默认情况下，一共有5个位置可以放静态资源，五个路径分别是如下五个：</p>
<ol>
<li>classpath:/MATA-INF/resources/</li>
<li>classpath:/resources/</li>
<li>classpath:/static/</li>
<li>classpath:/public/</li>
<li>/</li>
</ol>
<p>第5个<code>/</code>的意思是在 Spring Boot 项目中，默认是没有 webapp 这个目录的，当然我们也可以自己添加（例如在需要使用JSP的时候），这里第5个<code>/</code>其实就是表示webapp目录中的静态资源也不被拦截。如果同一个文件分别出现在五个目录下，那么优先级也是按照上面列出的顺序。<br>不过，虽然有5个存储目录，除了第5个用的比较少之外，其他四个，系统默认创建了<code>classpath:/static/</code>，正常情况下，我们只需要将我们的静态资源放到这个目录下即可，也不需要额外去创建其他静态资源目录。</p>
<h4 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h4><p>当然，这个是系统默认配置，如果我们并不想将资源放在系统默认的这五个位置上，也可以自定义静态资源位置和映射，自定义的方式也有两种，可以通过 application.properties 来定义，也可以在 Java 代码中来定义，下面分别来看。</p>
<h5 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h5><p>在配置文件中定义的方式比较简单，如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.resources.static-locations</span>=classpath:/</span><br><span class="line"><span class="attr">spring.mvc.static-path-pattern</span>=/**</span><br></pre></td></tr></table></figure>
<p>第一行配置表示定义资源位置，第二行配置表示定义请求URL规则。以上文的配置为例，如果我们这样定义了，表示可以将静态资源放在 resources目录下的任意地方，我们访问的时候当然也需要写完整的路径，例如在<code>resources/static</code>目录下有一张名为<code>1.png</code>的图片，那么访问路径就是<code>http://localhost:8080/static/1.png</code>，注意此时的static不能省略。</p>
<h5 id="Java-代码定义"><a href="#Java-代码定义" class="headerlink" title="Java 代码定义"></a>Java 代码定义</h5><p>当然，在SpringBoot中我们也可以通过Java代码来自定义，方式和Java配置的SSM比较类似，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMVCConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">"/**"</span>).addResourceLocations(<span class="string">"classpath:/aaa/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue环境搭建</title>
    <url>/2019/12/22/Vue%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="Vue的环境搭建以及NodeJS和npm"><a href="#Vue的环境搭建以及NodeJS和npm" class="headerlink" title="Vue的环境搭建以及NodeJS和npm"></a>Vue的环境搭建以及NodeJS和npm</h3><a id="more"></a>
<h4 id="Vue简介"><a href="#Vue简介" class="headerlink" title="Vue简介"></a>Vue简介</h4><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
<ol>
<li>只关注视图层</li>
<li>MVVM框架</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"num"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">"i in parseInt(num)"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">v-for</span>=<span class="string">"j in i"</span>&gt;</span>&#123;&#123;j&#125;&#125;*&#123;&#123;i&#125;&#125;=&#123;&#123;i*j&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">"#app"</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line">            num:9</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="npm-Node-package-manager"><a href="#npm-Node-package-manager" class="headerlink" title="npm(Node package manager)"></a>npm(Node package manager)</h4><p>npm是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，能更加方便管理。</p>
<h4 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h4><p>SPA（single page web application），单页面应用，是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，而非传统的从服务器重新加载整个新页面。这种方法避免了页面之间切换打断用户体验，使应用程序更像一个桌面应用程序。在单页应用中，所有必要的代码（ HTML、JavaScript 和 CSS）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面。SPA有一个缺点，因为SPA 应用部署后只有1个页面，而且这个页面只是一堆js、css引用，没有其他有效价值，因此，SPA应用不易被搜索引擎收录，所以，一般来说，SPA适合做大型企业后台管理系统。<br>Vue 使用方式大致上可以分为两大类：</p>
<ol>
<li>直接将Vue在页面中引入，不做 SPA 应用</li>
<li>SPA应用</li>
</ol>
<h4 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h4><p>首先需要安装两个东西：</p>
<ol>
<li>NodeJS</li>
<li>npm</li>
</ol>
<p>直接搜索下载NodeJS 即可，安装成功之后，npm 也就有了。安装成功之后，可以 在 cmd 命令行验证是否安装成功：</p>
<img src="/2019/12/22/Vue%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/WX20191222-175712@2x.png" class>
<p>NodeJS 安装成功之后，接下来安装 Vue的工具：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g vue-cli   <span class="comment"># 只需要第一次安装时执行</span></span><br><span class="line">vue init webpack my-<span class="keyword">project</span>  <span class="comment"># 使用webpack模板创建一个vue项目</span></span><br><span class="line">cd my-<span class="keyword">project</span> <span class="comment">#进入到项目目录中</span></span><br><span class="line">npm <span class="keyword">install</span>  <span class="comment"># 下载依赖（如果在项目创建的最后一步选择了自动执行npm install，则该步骤可以省略）</span></span><br><span class="line">npm run dev <span class="comment"># 启动项目</span></span><br></pre></td></tr></table></figure>

<p>启动成功后，浏览器输入<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 就能看到如下页面：</p>
<img src="/2019/12/22/Vue%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/WX20191222-184908@2x.png" class>
<p>执行<code>npm install</code>命令时，默认使用的是国外的下载源，可以通过如下代码配置为使用淘宝的镜像：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">npm <span class="built_in">config</span> <span class="built_in">set</span> registry https:<span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>

<h4 id="项目编译"><a href="#项目编译" class="headerlink" title="项目编译"></a>项目编译</h4><p>这么大一个前端项目，肯定没法直接发布运行，当开发者完成项目开发后，将 cmd 命令行定位到当前项目目录，然后执行如下命令对项目进行打包：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> build</span></span><br></pre></td></tr></table></figure>
<p>打包成功后，当前项目目录下会生成一个 dist 文件夹，这个文件夹中有两个文件，分别是 index.html 和 static ，index.html 页面就是我们 SPA 项目中唯一的 HTML 页面了，static 中则保存了编译后的 js、css等文件，项目发布时，可以使用 nginx 独立部署 dist 中的静态文件，也可以将静态文件拷贝到 Spring Boot 项目的 static 目录下，然后对 Spring Boot 项目进行编译打包发布。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用Mac搭建自己的博客</title>
    <url>/2019/12/22/%E5%A6%82%E4%BD%95%E7%94%A8Mac%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="今天是2020年考研的最后一天，我从今天开始写自己的博客了，为自己学习的知识找个地方存放，不断积累。"><a href="#今天是2020年考研的最后一天，我从今天开始写自己的博客了，为自己学习的知识找个地方存放，不断积累。" class="headerlink" title="今天是2020年考研的最后一天，我从今天开始写自己的博客了，为自己学习的知识找个地方存放，不断积累。"></a>今天是2020年考研的最后一天，我从今天开始写自己的博客了，为自己学习的知识找个地方存放，不断积累。</h3><a id="more"></a>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><h4 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h4><p><strong>实际上现在搭建一个个人博客，可选方案有很多种，我参照江南一点雨的方式，用Hexo来搭建，使用Hexo需要提前在电脑上安装好Node和Git，安装成功后就可以开始Hexo的安装了。</strong><br>步骤如下：<br>1.安装Hexo<br><code>sudo npm install -g hexo-cli</code><br>2.在本地创建一个博客目录<br><code>sudo init blog</code><br>上面这个目录执行完后，会在本地创建一个blog目录，这里面就是独立博客所必须的一些文件，然后给目录一个权限。<br>3.给目录一个权限<br><code>sudo chmod -R 777 blog/</code><br>之后进入这个目录中，执行<code>npm install</code>命令，安装相关的依赖。<br>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="variable">_config</span>.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── <span class="variable">_drafts</span></span><br><span class="line">|   └── <span class="variable">_posts</span></span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<p>_config.yml这个文件是站点的配置文件，package.json是应用程序的信息，scaffolds是模版文件夹，themes是主题文件夹。<br>配置完成后，定位到blog目录<code>cd blog/</code>，执行<code>hexo s</code>就可以在本地启动项目了，启动成功后，在浏览器中输入<code>http://localhost:4000</code>或者按住command键点终端中的链接就可以看到网站了。<br>说到<code>hexo s</code>命令，这里还有几个常用命令，分别是：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>简写</th>
<th>中文含义</th>
</tr>
</thead>
<tbody><tr>
<td>hexo server</td>
<td>hexo s</td>
<td>本地启动</td>
</tr>
<tr>
<td>hexo generate</td>
<td>hexo g</td>
<td>生成静态文件</td>
</tr>
<tr>
<td>hexo deploy</td>
<td>hexo d</td>
<td>部署网站</td>
</tr>
<tr>
<td>hexo clean</td>
<td></td>
<td>清除缓存和生成的静态文件</td>
</tr>
</tbody></table>
<p>这几个命令平时用的比较多</p>
<h4 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h4><p>一般来说，主题都会自己配置一个，Hexo现在提供282个主题，<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题地址</a>，Hexo默认的主题是landscape,我这里用了使用人数最多的hexo-theme-next主题（我个人觉得autumn主题也不错）。博客在本地能跑起来之后，接下来就是去修改主题，首先定位到你的Hexo站点目录下<code>cd blog/</code>，然后把主题文件克隆到你的<code>./themes</code>目录<code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code>，这个目录下原本有一个landscape文件夹，里边放的默认的样式，当然开发者也可以直接将主题文件下载好拷贝进去，但我还是建议你使用克隆最新版本的方式，因为之后的更新可以通过 git pull 来快速更新， 而不用再次下载压缩包替换。<br>克隆成功后，修改hexo的_config.yml文件，也就是站点配置文件，将主题修改为next，如下：<br><code>theme: next</code>，到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用<code>hexo clean</code>来清除Hexo的缓存。之后执行如下命令，即可看到最新的主题效果。<br><code>hexo g</code><br><code>hexo s</code></p>
<h4 id="绑定到GitHub"><a href="#绑定到GitHub" class="headerlink" title="绑定到GitHub"></a>绑定到GitHub</h4><p>博客光自己看怎么能行，我们选择把博客绑定到GitHub上，首先以<code>自己的GitHub ID . github . io</code>为名创建一个public仓库，例如我的ID为Kaciner，创建的仓库如下：</p>
<img src="/2019/12/22/%E5%A6%82%E4%BD%95%E7%94%A8Mac%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/WX20191222-155057@2x.png" class>
<p>创建成功之后，修改hexo的<code>_config.yml</code>文件，配置GitHub地址，如下</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:kaciner/kaciner.github.io.git</span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure>
<p>这里根据自己的地址来配置即可，配置完成后，执行如下命令<br><code>hexo g</code><br><code>hexo d</code><br>执行完成后，就可以将数据上传到GitHub了（当然在这之前如果你没配置过GitHub公钥甚至没有GitHub账号，需要先参考GitHub官方文档<a href="https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh" target="_blank" rel="noopener">配置远程仓库</a>），上传成功后，访问<code>https://kaciner.github.io</code>就可以看到自己的个人站点了。如果你对GitHub提供的域名不是特别满意，也可以自己申请一个域名，分分钟就配置好了。</p>
<h4 id="申请域名"><a href="#申请域名" class="headerlink" title="申请域名"></a>申请域名</h4><p>域名申请建议使用国外的域名提供商，不需要备案，我这里用的是.cn的域名，还得备案（哭了），我参考的大佬使用的是godaddy，因为是新加坡的域名服务商，还支持支付宝付款。</p>
<h4 id="域名和GitHub绑定"><a href="#域名和GitHub绑定" class="headerlink" title="域名和GitHub绑定"></a>域名和GitHub绑定</h4><h5 id="GitHub配置"><a href="#GitHub配置" class="headerlink" title="GitHub配置"></a>GitHub配置</h5><p>首先在博客所在目录下的 source 目录中，创建一个 CNAME 文件，文件内容就是你的域名，如下：</p>
<img src="/2019/12/22/%E5%A6%82%E4%BD%95%E7%94%A8Mac%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/WX20191222-161604@2x.png" class>
<p>然后执行 <code>hexo d</code> 命令将这个文件上传到 GitHub就可以了。</p>
<h4 id="域名解析设置"><a href="#域名解析设置" class="headerlink" title="域名解析设置"></a>域名解析设置</h4><p>域名解析这块，可以使用DNSPod去做域名解析，也可以使用godaddy自己提供的域名解析。我这里用的是DNSPod，所以首先要做的，就是修改godaddy提供的域名解析服务，登录自己的godaddy账号，找到域名管理，修改域名解析<br>服务为 DNSPod ，如下：</p>
<img src="/2019/12/22/%E5%A6%82%E4%BD%95%E7%94%A8Mac%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/WX20191222-161856@2x.png" class>
<p>然后登录到 DNSPod（没有账号注册一个），然后添加自己的域名解析，如下图：</p>
<img src="/2019/12/22/%E5%A6%82%E4%BD%95%E7%94%A8Mac%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/WX20191222-161947@2x.png" class>
<p>添加两条 A 记录，指向 GitHub 的 IP 地址，再添加一条 CNAME ，指向你的 GitHub 域名就可以了。<br>如此之后，大功告成！</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
